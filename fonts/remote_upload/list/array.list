{
  "list": [
    {
      "id": "UPLOAD_1735412450_ftrottvw2",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/refs/heads/main/fonts/remote_upload/wingding.ttf_encoded.json",
      "data": {
        "id": "UPLOAD_1735412450_ftrottvw2",
        "type": "application/octet-stream",
        "original_file_format": ".ttf",
        "timestamp": "2024-12-28T19:00:50.834Z",
        "title": "Windings",
        "description": "windings font (Gaster Font From Undertale)"
      }
    },
    {
      "id": "UPLOAD_1735412499_x8fv2i4tr",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/refs/heads/main/fonts/remote_upload/Poppins.zip_encoded.json",
      "data": {
        "id": "UPLOAD_1735412499_x8fv2i4tr",
        "type": "application/x-zip-compressed",
        "original_file_format": ".zip",
        "timestamp": "2024-12-28T19:01:39.299Z",
        "title": "Poppins",
        "description": "https://fonts.google.com/specimen/Poppins"
      }
    },
    {
      "id": "UPLOAD_1735412796_811orxhx9",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/refs/heads/main/fonts/remote_upload/Tinos.zip_encoded.json",
      "data": {
        "id": "UPLOAD_1735412796_811orxhx9",
        "type": "application/x-zip-compressed",
        "original_file_format": ".zip",
        "timestamp": "2024-12-28T19:06:36.902Z",
        "title": "Tinos",
        "description": "https://fonts.google.com/specimen/Tinos"
      }
    },
    {
      "id": "UPLOAD_1735412845_hayw8q61p",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/refs/heads/main/fonts/remote_upload/Orbitron.zip_encoded.json",
      "data": {
        "id": "UPLOAD_1735412845_hayw8q61p",
        "type": "application/x-zip-compressed",
        "original_file_format": ".zip",
        "timestamp": "2024-12-28T19:07:25.141Z",
        "title": "Orbiton",
        "description": "https://fonts.google.com/specimen/Orbitron"
      }
    },
    {
      "id": "UPLOAD_1735412962_y588i4jlr",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/refs/heads/main/fonts/remote_upload/tf2build.ttf_encoded.json",
      "data": {
        "id": "UPLOAD_1735412962_y588i4jlr",
        "type": "application/octet-stream",
        "original_file_format": ".ttf",
        "timestamp": "2024-12-28T19:09:22.474Z",
        "title": "Build",
        "description": "https://www.dafont.com/tf2-build.font"
      }
    },
    {
      "id": "UPLOAD_1735413903_lyrpxneiv",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/main/fonts/remote_upload/Comic_Sans_MS.ttf_encoded.json",
      "data": {
        "id": "UPLOAD_1735413903_lyrpxneiv",
        "type": "application/octet-stream",
        "original_file_format": ".ttf",
        "timestamp": "2024-12-28T19:25:03.499Z",
        "title": "Comic Sans MS",
        "description": "Best font ever"
      }
    },
    {
      "id": "UPLOAD_1735414094_65dk7yrr2",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/main/fonts/remote_upload/Wallpoet.zip_encoded.json",
      "data": {
        "id": "UPLOAD_1735414094_65dk7yrr2",
        "type": "application/x-zip-compressed",
        "original_file_format": ".zip",
        "timestamp": "2024-12-28T19:28:14.609Z",
        "title": "Wallpoet",
        "description": "https://fonts.google.com/specimen/Wallpoet"
      }
    },
    {
      "id": "UPLOAD_1735414617_puu8grglx",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/main/fonts/remote_upload/Playwrite_AU_VIC_Guides.zip_encoded.json",
      "data": {
        "id": "UPLOAD_1735414617_puu8grglx",
        "type": "application/x-zip-compressed",
        "original_file_format": ".zip",
        "timestamp": "2024-12-28T19:36:57.428Z",
        "title": "Playwrite_AU_VIC_Guides",
        "description": "https://fonts.google.com/specimen/Playwrite+AU+VIC+Guides"
      }
    },
    {
      "id": "UPLOAD_1735415208_sbi9u5h7l",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/main/fonts/remote_upload/Libre_Barcode_39.zip_encoded.json",
      "data": {
        "id": "UPLOAD_1735415208_sbi9u5h7l",
        "type": "application/x-zip-compressed",
        "original_file_format": ".zip",
        "timestamp": "2024-12-28T19:46:48.633Z",
        "title": "Libre_Barcode_39",
        "description": "https://fonts.google.com/specimen/Libre+Barcode+39"
      }
    },
    {
      "id": "UPLOAD_1735421549_f60j4p85p",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/main/fonts/remote_upload/Inkling_v2.otf_encoded.json",
      "data": {
        "id": "UPLOAD_1735421549_f60j4p85p",
        "type": "application/octet-stream",
        "original_file_format": ".otf",
        "timestamp": "2024-12-28T21:32:29.800Z",
        "title": "Inkling_v2",
        "description": "A Splatoon Language/Font"
      }
    },
    {
      "id": "UPLOAD_1735484919_em4zt1546",
      "raw_url": "https://raw.githubusercontent.com/DrMineword/Artefact-Boost-Active/main/fonts/remote_upload/sga-font.ttf_encoded.json",
      "data": {
        "id": "UPLOAD_1735484919_em4zt1546",
        "type": "application/octet-stream",
        "original_file_format": ".ttf",
        "timestamp": "2024-12-29T15:08:39.155Z",
        "title": "Standard Galactic Alphabet",
        "description": "The FontStruction “Minecraft - Standard Galactic Alphabet” (https://fontstruct.com/fontstructions/show/590785) by Robin Van der Vliet is licensed under a Creative Commons Attribution Non-commercial Share Alike license (http://creativecommons.org/licenses/by-nc-sa/3.0/).\n"
      }
    }
  ],
  "script_array": [
    {
      "type": ".zip",
      "console_log": "Loading zip64 to font script",
      "script": "(() => {\r\n  const base64Zip = \"${base64}\"; // Replace with your actual base64 string\r\n\r\n  // Function to dynamically load JSZip\r\n  function loadJSZip() {\r\n    return new Promise((resolve, reject) => {\r\n      const existingScript = document.querySelector('script[src=\"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\"]');\r\n      if (existingScript) {\r\n        console.log('JSZip is already loaded.');\r\n        return resolve();\r\n      }\r\n\r\n      const script = document.createElement('script');\r\n      script.src = \"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\";\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n\r\n  // Function to check if the base64 string is a ZIP file\r\n  function isZipFile(base64Data) {\r\n    const binaryString = atob(base64Data.slice(0, 100)); // Decode a portion of the base64 string\r\n    const zipSignature = [80, 75, 3, 4]; // PK\\x03\\x04\r\n    return zipSignature.every((byte, index) => binaryString.charCodeAt(index) === byte);\r\n  }\r\n\r\n  // Function to process ZIP file\r\n  async function processZip(base64Data) {\r\n    console.log('Processing as ZIP file...');\r\n\r\n    // Convert base64 to binary\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    // Use JSZip to unzip\r\n    const zip = await JSZip.loadAsync(byteArray);\r\n\r\n    // Extract font and .txt file\r\n    let fontBlob, txtContent;\r\n    await Promise.all(\r\n      Object.keys(zip.files).map(async (fileName) => {\r\n        if (fileName.endsWith('.ttf') || fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {\r\n          console.log(`Found font file: ${fileName}`);\r\n          fontBlob = await zip.files[fileName].async('blob');\r\n        } else if (fileName.endsWith('.txt')) {\r\n          console.log(`Found text file: ${fileName}`);\r\n          txtContent = await zip.files[fileName].async('string');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Print .txt file content\r\n    if (txtContent) {\r\n      console.log('TXT Content:', txtContent);\r\n    } else {\r\n      console.warn('No .txt file found in the ZIP.');\r\n    }\r\n\r\n    // Load the font\r\n    if (fontBlob) {\r\n      const fontUrl = URL.createObjectURL(fontBlob);\r\n      const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n      document.fonts.add(fontFace);\r\n\r\n      // Apply the font to the body\r\n      fontFace.load().then(() => {\r\n        document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n        console.log('Font loaded and applied successfully.');\r\n      });\r\n    } else {\r\n      console.warn('No font file found in the ZIP.');\r\n    }\r\n  }\r\n\r\n  // Function to process a standalone font file\r\n  function processFont(base64Data) {\r\n    console.log('Processing as standalone font file...');\r\n\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    const fontBlob = new Blob([byteArray]);\r\n    const fontUrl = URL.createObjectURL(fontBlob);\r\n    const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n    document.fonts.add(fontFace);\r\n\r\n    // Apply the font to the body\r\n    fontFace.load().then(() => {\r\n      document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n      console.log('Font loaded and applied successfully.');\r\n    });\r\n  }\r\n\r\n  // Main function to determine and process the input\r\n  async function processBase64(base64Data) {\r\n    try {\r\n      if (isZipFile(base64Data)) {\r\n        console.log('Detected ZIP file format.');\r\n        await processZip(base64Data);\r\n      } else {\r\n        console.log('Detected standalone font file format.');\r\n        processFont(base64Data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during processing:', error);\r\n    }\r\n  }\r\n\r\n  // Load JSZip and process the base64 data\r\n  loadJSZip()\r\n    .then(() => {\r\n      console.log('JSZip loaded successfully.');\r\n      processBase64(base64Zip);\r\n    })\r\n    .catch((err) => {\r\n      console.error('Failed to load JSZip:', err);\r\n    })\r\n    .finally(() => {\r\n      console.log('Clearing base64Zip and other variables.');\r\n      // Clear variables to avoid re-declaration issues\r\n      window.base64Zip = undefined;\r\n    });\r\n})();",
      "base64_var": "${base64}"
    },
    {
      "type": ".ttf",
      "console_log": "Loading ttf64 to font script",
      "script": "(() => {\r\n  const base64Zip = \"${base64}\"; // Replace with your actual base64 string\r\n\r\n  // Function to dynamically load JSZip\r\n  function loadJSZip() {\r\n    return new Promise((resolve, reject) => {\r\n      const existingScript = document.querySelector('script[src=\"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\"]');\r\n      if (existingScript) {\r\n        console.log('JSZip is already loaded.');\r\n        return resolve();\r\n      }\r\n\r\n      const script = document.createElement('script');\r\n      script.src = \"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\";\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n\r\n  // Function to check if the base64 string is a ZIP file\r\n  function isZipFile(base64Data) {\r\n    const binaryString = atob(base64Data.slice(0, 100)); // Decode a portion of the base64 string\r\n    const zipSignature = [80, 75, 3, 4]; // PK\\x03\\x04\r\n    return zipSignature.every((byte, index) => binaryString.charCodeAt(index) === byte);\r\n  }\r\n\r\n  // Function to process ZIP file\r\n  async function processZip(base64Data) {\r\n    console.log('Processing as ZIP file...');\r\n\r\n    // Convert base64 to binary\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    // Use JSZip to unzip\r\n    const zip = await JSZip.loadAsync(byteArray);\r\n\r\n    // Extract font and .txt file\r\n    let fontBlob, txtContent;\r\n    await Promise.all(\r\n      Object.keys(zip.files).map(async (fileName) => {\r\n        if (fileName.endsWith('.ttf') || fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {\r\n          console.log(`Found font file: ${fileName}`);\r\n          fontBlob = await zip.files[fileName].async('blob');\r\n        } else if (fileName.endsWith('.txt')) {\r\n          console.log(`Found text file: ${fileName}`);\r\n          txtContent = await zip.files[fileName].async('string');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Print .txt file content\r\n    if (txtContent) {\r\n      console.log('TXT Content:', txtContent);\r\n    } else {\r\n      console.warn('No .txt file found in the ZIP.');\r\n    }\r\n\r\n    // Load the font\r\n    if (fontBlob) {\r\n      const fontUrl = URL.createObjectURL(fontBlob);\r\n      const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n      document.fonts.add(fontFace);\r\n\r\n      // Apply the font to the body\r\n      fontFace.load().then(() => {\r\n        document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n        console.log('Font loaded and applied successfully.');\r\n      });\r\n    } else {\r\n      console.warn('No font file found in the ZIP.');\r\n    }\r\n  }\r\n\r\n  // Function to process a standalone font file\r\n  function processFont(base64Data) {\r\n    console.log('Processing as standalone font file...');\r\n\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    const fontBlob = new Blob([byteArray]);\r\n    const fontUrl = URL.createObjectURL(fontBlob);\r\n    const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n    document.fonts.add(fontFace);\r\n\r\n    // Apply the font to the body\r\n    fontFace.load().then(() => {\r\n      document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n      console.log('Font loaded and applied successfully.');\r\n    });\r\n  }\r\n\r\n  // Main function to determine and process the input\r\n  async function processBase64(base64Data) {\r\n    try {\r\n      if (isZipFile(base64Data)) {\r\n        console.log('Detected ZIP file format.');\r\n        await processZip(base64Data);\r\n      } else {\r\n        console.log('Detected standalone font file format.');\r\n        processFont(base64Data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during processing:', error);\r\n    }\r\n  }\r\n\r\n  // Load JSZip and process the base64 data\r\n  loadJSZip()\r\n    .then(() => {\r\n      console.log('JSZip loaded successfully.');\r\n      processBase64(base64Zip);\r\n    })\r\n    .catch((err) => {\r\n      console.error('Failed to load JSZip:', err);\r\n    })\r\n    .finally(() => {\r\n      console.log('Clearing base64Zip and other variables.');\r\n      // Clear variables to avoid re-declaration issues\r\n      window.base64Zip = undefined;\r\n    });\r\n})();",
      "base64_var": "${base64}"
    },
    {
      "type": ".otf",
      "console_log": "Loading otf64 to font script",
      "script": "(() => {\r\n  const base64Zip = \"${base64}\"; // Replace with your actual base64 string\r\n\r\n  // Function to dynamically load JSZip\r\n  function loadJSZip() {\r\n    return new Promise((resolve, reject) => {\r\n      const existingScript = document.querySelector('script[src=\"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\"]');\r\n      if (existingScript) {\r\n        console.log('JSZip is already loaded.');\r\n        return resolve();\r\n      }\r\n\r\n      const script = document.createElement('script');\r\n      script.src = \"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\";\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n\r\n  // Function to check if the base64 string is a ZIP file\r\n  function isZipFile(base64Data) {\r\n    const binaryString = atob(base64Data.slice(0, 100)); // Decode a portion of the base64 string\r\n    const zipSignature = [80, 75, 3, 4]; // PK\\x03\\x04\r\n    return zipSignature.every((byte, index) => binaryString.charCodeAt(index) === byte);\r\n  }\r\n\r\n  // Function to process ZIP file\r\n  async function processZip(base64Data) {\r\n    console.log('Processing as ZIP file...');\r\n\r\n    // Convert base64 to binary\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    // Use JSZip to unzip\r\n    const zip = await JSZip.loadAsync(byteArray);\r\n\r\n    // Extract font and .txt file\r\n    let fontBlob, txtContent;\r\n    await Promise.all(\r\n      Object.keys(zip.files).map(async (fileName) => {\r\n        if (fileName.endsWith('.ttf') || fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {\r\n          console.log(`Found font file: ${fileName}`);\r\n          fontBlob = await zip.files[fileName].async('blob');\r\n        } else if (fileName.endsWith('.txt')) {\r\n          console.log(`Found text file: ${fileName}`);\r\n          txtContent = await zip.files[fileName].async('string');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Print .txt file content\r\n    if (txtContent) {\r\n      console.log('TXT Content:', txtContent);\r\n    } else {\r\n      console.warn('No .txt file found in the ZIP.');\r\n    }\r\n\r\n    // Load the font\r\n    if (fontBlob) {\r\n      const fontUrl = URL.createObjectURL(fontBlob);\r\n      const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n      document.fonts.add(fontFace);\r\n\r\n      // Apply the font to the body\r\n      fontFace.load().then(() => {\r\n        document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n        console.log('Font loaded and applied successfully.');\r\n      });\r\n    } else {\r\n      console.warn('No font file found in the ZIP.');\r\n    }\r\n  }\r\n\r\n  // Function to process a standalone font file\r\n  function processFont(base64Data) {\r\n    console.log('Processing as standalone font file...');\r\n\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    const fontBlob = new Blob([byteArray]);\r\n    const fontUrl = URL.createObjectURL(fontBlob);\r\n    const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n    document.fonts.add(fontFace);\r\n\r\n    // Apply the font to the body\r\n    fontFace.load().then(() => {\r\n      document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n      console.log('Font loaded and applied successfully.');\r\n    });\r\n  }\r\n\r\n  // Main function to determine and process the input\r\n  async function processBase64(base64Data) {\r\n    try {\r\n      if (isZipFile(base64Data)) {\r\n        console.log('Detected ZIP file format.');\r\n        await processZip(base64Data);\r\n      } else {\r\n        console.log('Detected standalone font file format.');\r\n        processFont(base64Data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during processing:', error);\r\n    }\r\n  }\r\n\r\n  // Load JSZip and process the base64 data\r\n  loadJSZip()\r\n    .then(() => {\r\n      console.log('JSZip loaded successfully.');\r\n      processBase64(base64Zip);\r\n    })\r\n    .catch((err) => {\r\n      console.error('Failed to load JSZip:', err);\r\n    })\r\n    .finally(() => {\r\n      console.log('Clearing base64Zip and other variables.');\r\n      // Clear variables to avoid re-declaration issues\r\n      window.base64Zip = undefined;\r\n    });\r\n})();",
      "base64_var": "${base64}"
    },
    {
      "type": "zip",
      "console_log": "Loading zip64 to font script",
      "script": "(() => {\r\n  const base64Zip = \"${base64}\"; // Replace with your actual base64 string\r\n\r\n  // Function to dynamically load JSZip\r\n  function loadJSZip() {\r\n    return new Promise((resolve, reject) => {\r\n      const existingScript = document.querySelector('script[src=\"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\"]');\r\n      if (existingScript) {\r\n        console.log('JSZip is already loaded.');\r\n        return resolve();\r\n      }\r\n\r\n      const script = document.createElement('script');\r\n      script.src = \"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\";\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n\r\n  // Function to check if the base64 string is a ZIP file\r\n  function isZipFile(base64Data) {\r\n    const binaryString = atob(base64Data.slice(0, 100)); // Decode a portion of the base64 string\r\n    const zipSignature = [80, 75, 3, 4]; // PK\\x03\\x04\r\n    return zipSignature.every((byte, index) => binaryString.charCodeAt(index) === byte);\r\n  }\r\n\r\n  // Function to process ZIP file\r\n  async function processZip(base64Data) {\r\n    console.log('Processing as ZIP file...');\r\n\r\n    // Convert base64 to binary\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    // Use JSZip to unzip\r\n    const zip = await JSZip.loadAsync(byteArray);\r\n\r\n    // Extract font and .txt file\r\n    let fontBlob, txtContent;\r\n    await Promise.all(\r\n      Object.keys(zip.files).map(async (fileName) => {\r\n        if (fileName.endsWith('.ttf') || fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {\r\n          console.log(`Found font file: ${fileName}`);\r\n          fontBlob = await zip.files[fileName].async('blob');\r\n        } else if (fileName.endsWith('.txt')) {\r\n          console.log(`Found text file: ${fileName}`);\r\n          txtContent = await zip.files[fileName].async('string');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Print .txt file content\r\n    if (txtContent) {\r\n      console.log('TXT Content:', txtContent);\r\n    } else {\r\n      console.warn('No .txt file found in the ZIP.');\r\n    }\r\n\r\n    // Load the font\r\n    if (fontBlob) {\r\n      const fontUrl = URL.createObjectURL(fontBlob);\r\n      const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n      document.fonts.add(fontFace);\r\n\r\n      // Apply the font to the body\r\n      fontFace.load().then(() => {\r\n        document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n        console.log('Font loaded and applied successfully.');\r\n      });\r\n    } else {\r\n      console.warn('No font file found in the ZIP.');\r\n    }\r\n  }\r\n\r\n  // Function to process a standalone font file\r\n  function processFont(base64Data) {\r\n    console.log('Processing as standalone font file...');\r\n\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    const fontBlob = new Blob([byteArray]);\r\n    const fontUrl = URL.createObjectURL(fontBlob);\r\n    const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n    document.fonts.add(fontFace);\r\n\r\n    // Apply the font to the body\r\n    fontFace.load().then(() => {\r\n      document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n      console.log('Font loaded and applied successfully.');\r\n    });\r\n  }\r\n\r\n  // Main function to determine and process the input\r\n  async function processBase64(base64Data) {\r\n    try {\r\n      if (isZipFile(base64Data)) {\r\n        console.log('Detected ZIP file format.');\r\n        await processZip(base64Data);\r\n      } else {\r\n        console.log('Detected standalone font file format.');\r\n        processFont(base64Data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during processing:', error);\r\n    }\r\n  }\r\n\r\n  // Load JSZip and process the base64 data\r\n  loadJSZip()\r\n    .then(() => {\r\n      console.log('JSZip loaded successfully.');\r\n      processBase64(base64Zip);\r\n    })\r\n    .catch((err) => {\r\n      console.error('Failed to load JSZip:', err);\r\n    })\r\n    .finally(() => {\r\n      console.log('Clearing base64Zip and other variables.');\r\n      // Clear variables to avoid re-declaration issues\r\n      window.base64Zip = undefined;\r\n    });\r\n})();",
      "base64_var": "${base64}"
    },
    {
      "type": "ttf",
      "console_log": "Loading ttf64 to font script",
      "script": "(() => {\r\n  const base64Zip = \"${base64}\"; // Replace with your actual base64 string\r\n\r\n  // Function to dynamically load JSZip\r\n  function loadJSZip() {\r\n    return new Promise((resolve, reject) => {\r\n      const existingScript = document.querySelector('script[src=\"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\"]');\r\n      if (existingScript) {\r\n        console.log('JSZip is already loaded.');\r\n        return resolve();\r\n      }\r\n\r\n      const script = document.createElement('script');\r\n      script.src = \"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\";\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n\r\n  // Function to check if the base64 string is a ZIP file\r\n  function isZipFile(base64Data) {\r\n    const binaryString = atob(base64Data.slice(0, 100)); // Decode a portion of the base64 string\r\n    const zipSignature = [80, 75, 3, 4]; // PK\\x03\\x04\r\n    return zipSignature.every((byte, index) => binaryString.charCodeAt(index) === byte);\r\n  }\r\n\r\n  // Function to process ZIP file\r\n  async function processZip(base64Data) {\r\n    console.log('Processing as ZIP file...');\r\n\r\n    // Convert base64 to binary\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    // Use JSZip to unzip\r\n    const zip = await JSZip.loadAsync(byteArray);\r\n\r\n    // Extract font and .txt file\r\n    let fontBlob, txtContent;\r\n    await Promise.all(\r\n      Object.keys(zip.files).map(async (fileName) => {\r\n        if (fileName.endsWith('.ttf') || fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {\r\n          console.log(`Found font file: ${fileName}`);\r\n          fontBlob = await zip.files[fileName].async('blob');\r\n        } else if (fileName.endsWith('.txt')) {\r\n          console.log(`Found text file: ${fileName}`);\r\n          txtContent = await zip.files[fileName].async('string');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Print .txt file content\r\n    if (txtContent) {\r\n      console.log('TXT Content:', txtContent);\r\n    } else {\r\n      console.warn('No .txt file found in the ZIP.');\r\n    }\r\n\r\n    // Load the font\r\n    if (fontBlob) {\r\n      const fontUrl = URL.createObjectURL(fontBlob);\r\n      const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n      document.fonts.add(fontFace);\r\n\r\n      // Apply the font to the body\r\n      fontFace.load().then(() => {\r\n        document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n        console.log('Font loaded and applied successfully.');\r\n      });\r\n    } else {\r\n      console.warn('No font file found in the ZIP.');\r\n    }\r\n  }\r\n\r\n  // Function to process a standalone font file\r\n  function processFont(base64Data) {\r\n    console.log('Processing as standalone font file...');\r\n\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    const fontBlob = new Blob([byteArray]);\r\n    const fontUrl = URL.createObjectURL(fontBlob);\r\n    const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n    document.fonts.add(fontFace);\r\n\r\n    // Apply the font to the body\r\n    fontFace.load().then(() => {\r\n      document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n      console.log('Font loaded and applied successfully.');\r\n    });\r\n  }\r\n\r\n  // Main function to determine and process the input\r\n  async function processBase64(base64Data) {\r\n    try {\r\n      if (isZipFile(base64Data)) {\r\n        console.log('Detected ZIP file format.');\r\n        await processZip(base64Data);\r\n      } else {\r\n        console.log('Detected standalone font file format.');\r\n        processFont(base64Data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during processing:', error);\r\n    }\r\n  }\r\n\r\n  // Load JSZip and process the base64 data\r\n  loadJSZip()\r\n    .then(() => {\r\n      console.log('JSZip loaded successfully.');\r\n      processBase64(base64Zip);\r\n    })\r\n    .catch((err) => {\r\n      console.error('Failed to load JSZip:', err);\r\n    })\r\n    .finally(() => {\r\n      console.log('Clearing base64Zip and other variables.');\r\n      // Clear variables to avoid re-declaration issues\r\n      window.base64Zip = undefined;\r\n    });\r\n})();",
      "base64_var": "${base64}"
    },
    {
      "type": "otf",
      "console_log": "Loading otf64 to font script",
      "script": "(() => {\r\n  const base64Zip = \"${base64}\"; // Replace with your actual base64 string\r\n\r\n  // Function to dynamically load JSZip\r\n  function loadJSZip() {\r\n    return new Promise((resolve, reject) => {\r\n      const existingScript = document.querySelector('script[src=\"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\"]');\r\n      if (existingScript) {\r\n        console.log('JSZip is already loaded.');\r\n        return resolve();\r\n      }\r\n\r\n      const script = document.createElement('script');\r\n      script.src = \"https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js\";\r\n      script.onload = resolve;\r\n      script.onerror = reject;\r\n      document.head.appendChild(script);\r\n    });\r\n  }\r\n\r\n  // Function to check if the base64 string is a ZIP file\r\n  function isZipFile(base64Data) {\r\n    const binaryString = atob(base64Data.slice(0, 100)); // Decode a portion of the base64 string\r\n    const zipSignature = [80, 75, 3, 4]; // PK\\x03\\x04\r\n    return zipSignature.every((byte, index) => binaryString.charCodeAt(index) === byte);\r\n  }\r\n\r\n  // Function to process ZIP file\r\n  async function processZip(base64Data) {\r\n    console.log('Processing as ZIP file...');\r\n\r\n    // Convert base64 to binary\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    // Use JSZip to unzip\r\n    const zip = await JSZip.loadAsync(byteArray);\r\n\r\n    // Extract font and .txt file\r\n    let fontBlob, txtContent;\r\n    await Promise.all(\r\n      Object.keys(zip.files).map(async (fileName) => {\r\n        if (fileName.endsWith('.ttf') || fileName.endsWith('.woff') || fileName.endsWith('.woff2')) {\r\n          console.log(`Found font file: ${fileName}`);\r\n          fontBlob = await zip.files[fileName].async('blob');\r\n        } else if (fileName.endsWith('.txt')) {\r\n          console.log(`Found text file: ${fileName}`);\r\n          txtContent = await zip.files[fileName].async('string');\r\n        }\r\n      })\r\n    );\r\n\r\n    // Print .txt file content\r\n    if (txtContent) {\r\n      console.log('TXT Content:', txtContent);\r\n    } else {\r\n      console.warn('No .txt file found in the ZIP.');\r\n    }\r\n\r\n    // Load the font\r\n    if (fontBlob) {\r\n      const fontUrl = URL.createObjectURL(fontBlob);\r\n      const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n      document.fonts.add(fontFace);\r\n\r\n      // Apply the font to the body\r\n      fontFace.load().then(() => {\r\n        document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n        console.log('Font loaded and applied successfully.');\r\n      });\r\n    } else {\r\n      console.warn('No font file found in the ZIP.');\r\n    }\r\n  }\r\n\r\n  // Function to process a standalone font file\r\n  function processFont(base64Data) {\r\n    console.log('Processing as standalone font file...');\r\n\r\n    const binaryString = atob(base64Data);\r\n    const byteArray = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n      byteArray[i] = binaryString.charCodeAt(i);\r\n    }\r\n\r\n    const fontBlob = new Blob([byteArray]);\r\n    const fontUrl = URL.createObjectURL(fontBlob);\r\n    const fontFace = new FontFace('DynamicFont', `url(${fontUrl})`);\r\n    document.fonts.add(fontFace);\r\n\r\n    // Apply the font to the body\r\n    fontFace.load().then(() => {\r\n      document.body.style.fontFamily = 'DynamicFont, sans-serif';\r\n      console.log('Font loaded and applied successfully.');\r\n    });\r\n  }\r\n\r\n  // Main function to determine and process the input\r\n  async function processBase64(base64Data) {\r\n    try {\r\n      if (isZipFile(base64Data)) {\r\n        console.log('Detected ZIP file format.');\r\n        await processZip(base64Data);\r\n      } else {\r\n        console.log('Detected standalone font file format.');\r\n        processFont(base64Data);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error during processing:', error);\r\n    }\r\n  }\r\n\r\n  // Load JSZip and process the base64 data\r\n  loadJSZip()\r\n    .then(() => {\r\n      console.log('JSZip loaded successfully.');\r\n      processBase64(base64Zip);\r\n    })\r\n    .catch((err) => {\r\n      console.error('Failed to load JSZip:', err);\r\n    })\r\n    .finally(() => {\r\n      console.log('Clearing base64Zip and other variables.');\r\n      // Clear variables to avoid re-declaration issues\r\n      window.base64Zip = undefined;\r\n    });\r\n})();",
      "base64_var": "${base64}"
    }
  ]
}
